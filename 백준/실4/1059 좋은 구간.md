# 1059 좋은 구간
---
### 문제
정수 집합 S가 주어졌을때, 다음 조건을 만족하는 구간 [A, B]를 좋은 구간이라고 한다.

A와 B는 양의 정수이고, A < B를 만족한다.
A ≤ x ≤ B를 만족하는 모든 정수 x가 집합 S에 속하지 않는다.
집합 S와 n이 주어졌을 때, n을 포함하는 좋은 구간의 개수를 구해보자.

---
### 입력
첫째 줄에 집합 S의 크기 L이 주어진다. 둘째 줄에는 집합에 포함된 정수가 주어진다. 셋째 줄에는 n이 주어진다.

---
### 출력
첫째 줄에 n을 포함하는 좋은 구간의 개수를 출력한다.

---
### 제한
1 ≤ L ≤ 50
집합 S에는 중복되는 정수가 없다.
집합 S에 포함된 모든 정수는 1보다 크거나 같고, 1,000보다 작거나 같다.
1 ≤ n ≤ (집합 S에서 가장 큰 정수)

---
### 예제 입력
```
4
1 7 14 10
2
```
### 예제 출력
```
4
```
---
### 코드
```swift
let L = Int(readLine()!)!
var S = readLine()!.split(separator: " ").map { Int($0)! }
let n = Int(readLine()!)!

S.sort()

if S.contains(n) {
    print(0)
} else {
    var left = 1
    var right = 1000
    
    for num in S {
        if num < n {
            left = num + 1
        } else if num > n {
            right = num - 1
            break
        }
    }

    let count = (n - left + 1) * (right - n + 1) - 1
    print(count)
}
```
---
### 풀이
**1행 ~ 3행**
L : 집합 S의 크기
S : 요소 입력 받기
n : 정수로 입력 받기

**5행**
집합 정렬

**7행 ~ 9행**
n이 S에 포함 되어 있는지 확인하고 포함되어 있다면 0 출력하고 종료

**9행 ~ 11행**
포함되지 않을 경우
left : 가능한 구간의 최소 시작점
right : 가능한 구간의 최대 끝점
으로 초기화 됨
right는 충분히 큰 값으로 설정함

**13행 ~ 20행**
left 값과 right 값 찾기
**num < n일 때**
num이 n보다 작으므로 left를 num + 1로 업데이트
왜냐? num과 n 사이의 값이 집합에 포함되지 않도록 해야 하기 때문
**num > n일 때**
num이 n보다 크므로 right를 num - 1로 업데이트
왜냐? num과 n 사이의 값이 집합에 포함되지 않도록 해야 하기 때문
첫 번째 num > n인 경우로 찾으면 더 이상 순회할 필요가 없기 때문에 break로 루프 종료

**22행 ~ 24행**
n - left + 1 : n을 포함하는 구간의 시작점 후보의 개수
right - n + 1 : n을 포함하는 구간의 끝점 후보의 개수
두 값을 곱한 후 n 하나만 포함하는 구간을 제외하기 위해 -1을 해줌
